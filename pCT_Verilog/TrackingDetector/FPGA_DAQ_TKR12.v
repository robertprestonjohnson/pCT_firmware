//Complete DAQ program for twelve chips, to run in the Spartan-6 FPGAs on the Tracker V & T boards.
//R. Johnson  May 21, 2013
//May 29, 2013, added commands to calibrate the input delays for the data arriving from the ASICs
//May 29, 2013, tested successfully at 100 MHz on the Tracker V board, with command delays set to 196
//June 19, 2013, added hard reset for the front-end chips
//June 26, 2013, added bit pattern for the 12 TReq signals in calibration TOT data packets
//July 12, 2013, added version number, set to Version 5, sent out with the test pattern
//July 19, 2013, first setup for the T boards, V6
//July 25, 2013, increase time waiting for mask register readback, so all 66 bits are sent
//July 28, 2013, add mask register to select working chips, V9
//July 29, 2013, use the mask register for Data and TReq, V10
//August 12, 2013, added count of trigger and parity errors, V11
//August 16, 2013, finally got all parity checks working,  V12
//August 17, 2013, added parity bit to trigger stream,  V13
//August 20, 2013, added a 1 bit to the end of the TOT stream, V14
//August 24, 2013, added count of fastORs going out, V15
//August 27, 2013, modified reset scheme, V16
//August 28, 2013, fixed buffer occupancy monitoring (hopefully), V17
//September 10, 2013, Added configuration reset command, V18
//October 3, 2013, Added checking of the read tag sequence, V19
//November 19, 2013, Read out configuration, V20
//December 5, 2013, Added command to disable trigger signal to the ASICs, for calibration events, V21
//January 31, 2014, Set the ASIC power enable to false at startup, for thermal safety, V22
//March 7, 2014, add diagnostics for detected errors, V23
//March 16, 2014, Simplify buffer clear reporting, V24
//April 3, 2014, Add the data transmission test feature, V25
//April 8, 2014, modified DataMon.v to try to avoid timing errors, V26
//April 12, 2014, complete rewrite of the data receiving and merging code, V27
//April 18, 2014, fixed bugs in the new code.  Seems to work error free now.  V28
//April 28, 2014, improvements in BufSgnl, V29
//April 30, 2014, fixed bug that was dropping the last bit of the data stream, V30
//August 19, 2014, improvements in ErrBuf reporting, V31
//August 22, 2014, improve timing of signals vs clock going to ASICs, V32
//October 10, 2014, add programmable timing delays for the TACK, V33

module FPGA_DAQ_TKR12(Diag1,Diag2,Diag3,Diag4,OutputUsage,BufClr,RSTchips,Reset,CALIO,CALEN,CALINC,CALRST,PWREN,
																Dout,FastOR,CMDtoChips,Tack,Clock,ResetHard,CmdIn,TrgIn,DataIn,TReqIn,Address);
input [3:0] Address;  //FPGA address, on the tracker boards to be set by dip switches
input Clock;          //Clock for the FPGA (C9, A9)    (Phase-shifted output clock needs to go to P8, T8 to send clock to the chips)
input ResetHard;      //Reset everything, including the command decoding state machine (P7, M7)
input CmdIn;          //Input DAQ commands (F7, E6)
input TrgIn;          //Tack input (D5, C5)
input [11:0] DataIn;  //Serial data streams from the pCTFE64 chips 
input [11:0] TReqIn;  //Trigger outputs from the pCTFE64 chips 
output Reset;		  //Soft reset generated by command
output BufClr;		  //Signal that an ASIC buffer has cleared
output [1:0] Tack;    //Trigger acknowledge going to the pCTFE64 chips (M9, N8)
output CMDtoChips;    //Commands going to the pCTFE64 chips (R9, T9)
output Dout;          //Output serial data stream (B6, A6)
output FastOR;        //Output OR of all 6 trigger requests (B5, A5)
output PWREN;		  //Enable for the analog power on the board
output RSTchips;	  //Send a hard reset pulse to the front-end chips
output Diag1, Diag2;  //Signals output to the scope probe pins for debugging
output Diag3, Diag4;	 //Signals output to the scope probe pins for debugging
output CALIO;			 //Signal to initiate calibration of the data input delays
output CALEN;			 //Enable signal for delay increment/decrement
output CALINC;			 //Increment (1) or decrement (0) delay
output CALRST;			 //Reset delay to middle
output OutputUsage;		 //Send either trigger or buffer clear signals to the event builder (for T boards)

parameter [7:0] Version=8'd34;

wire [11:0] Data,TReq;
wire [3:0] Address;
reg Dout, CMDtoChips;
reg PWREN, CALIO, CALEN, CALINC, CALRST;
reg [11:0] Mask;

reg [7:0] CmdByte, DatByte;		//Registers for extended commands
reg CalStrobe;					//Signal that a calibration command has been sent to the ASICs
reg Reset;    					//Reset pulse generated by command
reg [3:0] UnDoBuf;    			//Signal that the corresponding front-end buffer has cleared

reg Parity;				//Parity calculated for local command received 
reg PrtyError;			//Store parity error
reg [9:0] CmdSav;   	//Saved ASIC command string, extracted from the incoming bit stream
reg InProg;				//Set while a run is in progress
reg EndRun;				//Pulse to signal end of run
reg [6:0] StrtSq;   	//Start sequence for register readback, inserted before the bits from the ASIC

reg TOTdata, SendEvt, RSTchips;
reg [77:0] RegOut;	//Register for shifting out the test string and DAQ counters

//Mask out chips that are not installed or are not working
assign TReq = TReqIn & Mask;
assign Data = DataIn & Mask;

//Short command definitions (3-bit commands to this FPGA program)
// 0: Send a test string back to the DAQ
// 1: Read in an extended 2-byte command
// 2: Start a run.  During the run, no commands should be sent except for read and end-run.  
// 3: End a run.
// 4: Read back DAQ counters; see command h06 for setting what will be read back
// 5: Reset counters and variables in this code
// 6: Reset the front-end ASICs without altering their registers (takes about 1 millisecond to complete)
// 7: Read a merged event from the local buffers and send it to the event builder (as soon as it is available)

//Extended Command Definitions.  Second byte is a data byte, or 0
// h01: Set the power enable to the LSB of the data byte
// h02: Initiate calibration of the input delay for data from the front-end chips
// h03: Set reset for the input delay
// h04: Send increment or decrement for the input delay, controlled by LSB of data byte
// h05: Send a hard reset pulse to the ASICs
// h06: Set what should be written out in a read DAQ counters command
//           0= number of triggers in and out
//           1= buffer occupancies
//           2= error counts
//           3= send and read counts
//			 4= read tag sequencing
//           5= configuration parameters
//           6= error buffer
// h07: Set lower 6 bits of the mask register to select chips that are attached and working
// h08: Set upper 6 bits of the mask register
// h09: Reset the configuration
// h0A: Select usage of the trigger/buffer-clear LVDS connection:  1=Buffer-clear,  0=Trigger request
// h0B: Select trigger type: 0=normal trigger, 1=calibration trigger (ASICs are triggered internally)
// h0C: Send a test stream to the event builder to test data transmission
// h0D: Set the trigger delays: bits [1:0]=left, bits [5:4] right

//Command format:   
//  start bit
//  4-bit address of the FPGA board
//  routing bit:  1=complete command to ASICs follows    0=command to this program
//  3-bit short local command  
//  Optional 2-Byte extended command (if the 3-bit short command is 001)
//  parity bit, not counting the start bit
//
//	Note:  during a run no commands should be sent besides end-run (except that Read commands will be
//         sent automatically from the event builder buffer manager).  This program is not protected against
//         receiving other commands, such as read register, which would disrupt the data acquisition.  To avoid
//         delaying the data acquisition, the incoming commands stream is not checked before forwarding it to 
//         the ASICs.  This program also does not check the parity of ASIC commands.  But the ASICs themselves
//         will do that.

//initial begin
//	$display("Time     StateTOT TReqChip CalStrobe CntStrt CntTOT CntShft TOTHeader TOTNclus TOTdata");
//  $display("Time        State    CmdIn TrgIn   Cnt   InProg Data   TReq CMD Dout RegIn   StrtSq TC RRC StateRd CntRd2 TrgCode RdStrng SndEvt");
//end

//always @ (posedge Clock) begin
//   $display("%g\t  %b %b     %b  %b %b   %b %b %b   %b       %b %b %b %b %b     %b    %b  %b    %b",$time,State,CmdIn,TrgIn, Cnt,InProg,Data,TReq,CMDtoChips,Dout,RegIn,StrtSq,ThisFPGA,ReadRegCmd,StateRd,CntRd2,TrgCode,RdString,SendEvt);
//end

//State machine to receive the trigger, check it, and pass it to the ASICs
parameter [3:0] WaitTg=4'b0001;
parameter [3:0] Snd1Tg=4'b0010;
parameter [3:0] Snd2Tg=4'b0100;
parameter [3:0] PrtyTg=4'b1000;
reg [3:0] StateTg, NextStateTg;
reg [1:0] TrgTag;
reg TrgPls, ParityTg, Tack1;
reg [1:0] Tack;

always @ (StateTg or TrgIn or CalTrigger) begin
	case (StateTg)
		WaitTg:	begin
					if (TrgIn) NextStateTg = Snd1Tg;
					else NextStateTg = WaitTg;
					if (CalTrigger) Tack1 = 1'b0;
					else Tack1 = TrgIn;
				end
		Snd1Tg:	begin
					NextStateTg = Snd2Tg;
					if (CalTrigger) Tack1 = 1'b0;
					else Tack1 = TrgIn;
				end
		Snd2Tg:	begin
					NextStateTg = PrtyTg;
					if (CalTrigger) Tack1 = 1'b0;
					else Tack1 = TrgIn;
				end
		PrtyTg:	begin
					NextStateTg = WaitTg;
					Tack1 = 1'b0;			//The ASICs cannot receive the parity bit
				end
		default:	begin
						Tack1= 1'b0;
						NextStateTg = WaitTg;
					end
	endcase
end

// Add a programmable trigger delay
reg [2:0] TackDly;
always @ (posedge Clock) begin
    if (Reset) begin
	    TackDly <= 0;
	end else begin
	    TackDly <= {TackDly[1:0], Tack1};
	end
end

reg [1:0] TrgDlyL, TrgDlyR;
always @ (TackDly or Tack1 or TrgDlyL) begin
    case (TrgDlyL) 
	   2'b00: Tack[0] = Tack1;
		2'b01: Tack[0] = TackDly[0];
		2'b10: Tack[0] = TackDly[1];
		2'b11: Tack[0] = TackDly[2];
	endcase
end
always @ (TackDly or Tack1 or TrgDlyR) begin
    case (TrgDlyR) 
	   2'b00: Tack[1] = Tack1;
		2'b01: Tack[1] = TackDly[0];
		2'b10: Tack[1] = TackDly[1];
		2'b11: Tack[1] = TackDly[2];
	endcase
end

reg [15:0] NTgPrty, Nsequence;
reg [1:0] LastTag;
wire [1:0] LastTagP1;
assign LastTagP1 = LastTag + 1;
always @ (posedge Clock) begin
	if (Reset) begin
		StateTg <= WaitTg;
		NTgPrty <= 0;
		LastTag <= 2'b11;
		Nsequence <= 0;
	end else begin
		StateTg <= NextStateTg;
		case (StateTg) 
			WaitTg:	begin
						ParityTg <= 1'b1;
						TrgPls <= 1'b0;
					end
			Snd1Tg:	begin
						TrgTag[1] <= TrgIn;
						ParityTg <= ParityTg^TrgIn;
					end
			Snd2Tg:	begin
						TrgTag[0] <= TrgIn;
						ParityTg <= ParityTg^TrgIn;
						TrgPls <= 1'b1;
					end
			PrtyTg:	begin
						LastTag <= TrgTag;
						if (LastTagP1[1] != TrgTag[1] || LastTagP1[0] != TrgTag[0]) begin
							$display("%g\t FPGA_DAQ_TKR12 %d: trigger tag out of sequence, %d %d.",$time,Address,LastTag,TrgTag);
							Nsequence <= Nsequence + 1;
						end
						TrgPls <= 1'b0;
						if (ParityTg^TrgIn) begin
							NTgPrty <= NTgPrty + 1;
							$display("%g\t FPGA_DAQ_TKR12 %d: parity error on trigger input.",$time,Address);
						end
					end
		endcase
	end
end

reg [7:0] Choice;
assign TReqChip =   (TReq != 12'b000000000000);   	//OR of all ASIC trigger outputs
assign FastOR =  InProg & TReqChip;  				//Tracker trigger output
//always @ (posedge FastOR) $display("%g\t FPGA_DAQ_TKR12 %d:  FastOR fires;  TReq=%b",$time,Address,TReq);

//Count triggers in and out
wire [31:0] NFastOR;
TrgMon TrgMonTkr(Clock,Reset,FastOR,NFastOR);

//Here the buffer occupancy counting is used only for monitoring, not control
reg [2:0] NBufOcc;
reg [31:0] Ntriggers;
reg [31:0] NReads, NSends, NBfClr;
reg [15:0] NBuf1, NBuf2, NBuf3, NBuf4;
reg [15:0] NTrgErr, NPrtErr, Nerror;
reg TrgErr;
always @ (posedge Clock) begin
	if (Reset) begin
		Ntriggers <= 0;
		TrgErr <= 1'b0;
		NTrgErr <= 0;
		NBuf1 <= 0;
		NBuf2 <= 0;
		NBuf3 <= 0;
		NBuf4 <= 0;
		NBfClr <= 0;
		NBufOcc <= 0;
		Nerror <= 0;
	end else begin
		if (ErrorFE) begin
			Nerror <= Nerror + 1;
			$display("%g\t FPGA_DAQ_TKR12 %d: error pulse detected.  Nerror=%d",$time,Address,Nerror);
		end
		if (BufClr) begin
			NBfClr <= NBfClr + 1;
			if (!TrgPls) begin
				NBufOcc <= NBufOcc - 1;
				$display("%g\t FPGA_DAQ_TRK12 %d: decrementing front-end buffer occupancy to %d",$time,Address,NBufOcc-1);
				if (NBufOcc == 0) $display("%g\t FPGA_DAQ_TKR12 %d: front-end buffer underflow error!!!",$time,Address);
			end
		end
		if (BufClr & TrgPls) $display("%g\t FPGA_DAQ_TRK12 %d: simultaneous BufClr & TrgPls; buffer occupancy = %d",$time,Address,NBufOcc);
		if (TrgPls) begin
			if (!BufClr) begin	
				NBufOcc <= NBufOcc + 1;
				$display("%g\t FPGA_DAQ_TRK12 %d: incrementing front-end buffer occupancy to %d",$time,Address,NBufOcc+1);
				if (NBufOcc == 4) $display("%g\t FPGA_DAQ_TKR12 %d: front-end buffer overflow error!!!",$time,Address);
			end
			case (NBufOcc)
				3'b001: NBuf1 <= NBuf1 + 1;
				3'b010: NBuf2 <= NBuf2 + 1;
				3'b011: NBuf3 <= NBuf3 + 1;
				3'b100: NBuf4 <= NBuf4 + 1;
			endcase
			Ntriggers <= Ntriggers + 1;
		end
	end
end

//Names given to the eight commands:
parameter cmdTest = 3'b000;
parameter cmdExtd = 3'b001;
parameter cmdStRn = 3'b010;
parameter cmdEnRn = 3'b011;
parameter cmdRdFg = 3'b100;
parameter cmdRset = 3'b101;
parameter cmdRsCh = 3'b110;
parameter cmdSend = 3'b111;

//State machine to interpret and execute commands sent from the event builder
//Encoding of states:
parameter [14:0] Wait = 15'b000000000000001;  //Wait for a start bit
parameter [14:0] RdBt = 15'b000000000000010;  //Read the 4-bit address
parameter [14:0] Brch = 15'b000000000000100;  //Branch to chip vs local command
parameter [14:0] ACmd = 15'b000000000001000;  //Clock in the ASIC command and start bit
parameter [14:0] FeCd = 15'b000000000010000;  //Check the ASIC command
parameter [14:0] Ct66 = 15'b000000000100000;  //Wait some more clock cycles for the command to end or register data to come back
parameter [14:0] RdCm = 15'b000000001000000;  //Read in the 3-bit local command
parameter [14:0] Deco = 15'b000000010000000;  //Decode the local command
parameter [14:0] Prty = 15'b000000100000000;  //Check parity of local command
parameter [14:0] WrWd = 15'b000001000000000;  //Write out monitoring information or a test string
parameter [14:0] WtDn = 15'b000010000000000;  //Wait for front-end reset to finish
parameter [14:0] CmdB = 15'b000100000000000;  //Get the first byte of an extended command
parameter [14:0] DatB = 15'b001000000000000;  //Get the data byte of an extended command
parameter [14:0] XDco = 15'b010000000000000;  //Decode the extended command
parameter [14:0] Tsts = 15'b100000000000000;  //Test the data transmission line

reg [14:0] State, NextState;
reg [7:0] Cnt;     	//Eight-bit counter
reg [2:0] RegIn;   	//Register for shifting in and storing the command 
reg [3:0] AddrIn;   //Register for shifting in the FPGA address
reg [6:0] nDat;   	//Number of clocks needed to complete a front-end ASIC command
reg ResetSlow;
reg ResetCF;
reg CalTrigger;

always @ (State or CmdIn or Cnt or DoneRst or InProg or nDat or RegIn or CmdByte or Done or ThisFPGA)
begin:CombinatorialLogic
  case(State)
	Wait: 	begin
				if (CmdIn == 1'b1)   	//Trigger state machine on command start bit
					NextState=RdBt;
				else
					NextState=Wait;
			end
	RdBt:	begin
				if (Cnt == 3)			//Count in four address bits
					NextState=Brch;
				else
					NextState=RdBt;
			end
	Brch:	begin						//Branch to ASIC command or local command
				if (CmdIn) NextState=ACmd;
				else NextState=RdCm;
			end
	ACmd:	begin
			    if (Cnt == 9)			//Count in five ASIC address bits and 4 command bits
					NextState=FeCd;
				else
					NextState=ACmd;
			end
	FeCd:	begin
				NextState=Ct66;			//Look at the command received and set nDat; direct bit stream to ASICs
			end
	Ct66:	begin
				if (Cnt[6:0] == nDat)	//Wait long enough for command bits to go to ASIC and register data to come back
					NextState=Wait;
				else
					NextState=Ct66;
			end
	RdCm:	begin
				if (Cnt == 2) NextState = Deco;		//Count in the 3 local command bits
				else NextState = RdCm;
			end
	Deco:   begin 
				case (RegIn)						//Branch to appropriate execution for the command received
					cmdTest: NextState = WrWd;
					cmdExtd: NextState = CmdB;   
					cmdStRn: NextState = Prty;
					cmdEnRn: NextState = Prty;
					cmdRdFg: if (InProg)
								NextState=Prty;
							 else
								NextState=WrWd;
					cmdRset: NextState = Prty;
					cmdRsCh: NextState = WtDn;  
					cmdSend: NextState = Prty;
				endcase
			end
	WtDn:	begin								//Wait for the complete reset of the ASICs to complete (about 1 millisecond)
				if (DoneRst) NextState=Prty;
				else NextState=WtDn;
			end
	Prty:	begin								//Check the parity of the received local command (should be positive)
				NextState=Wait;
			end
	WrWd:	begin								//Shift a test string or DAQ counters into the output data stream
				if (Cnt==77)
					NextState=Prty;
				else
					NextState=WrWd;
			end
	CmdB:	begin
				if (Cnt == 6) NextState = DatB;
				else NextState = CmdB;
			end
	DatB:	begin
				if (Cnt == 7) NextState = XDco;
				else NextState = DatB;
			end
	XDco:	begin
				if (CmdByte == 8'h0C && ThisFPGA) NextState = Tsts;
				else NextState = Prty;
			end
	Tsts:	begin
				if (Done) NextState = Prty;		//Send a long test stream to the event builder to test data transmission
				else NextState = Tsts;
			end
	default:begin
				NextState=Wait;
			end
  endcase
 end
 
reg [15:0] NSeqReadTag;
reg [1:0] oldReadTag, TagRead;
wire [1:0] oldReadTagP1;
assign oldReadTagP1 = oldReadTag + 1;
reg OutputUsage;			//Flag to specify whether the output line is used for trigger or for buffer clear signals
 
always @ (posedge Clock)
begin:SequentialLogic
  if (Reset) begin				//This Reset is activated by command, but also by the ResetHard
	PrtyError <= 1'b0;
	NPrtErr <= 0;
	NReads <= 0;
	NSends <= 0;
	SendEvt <= 1'b0;
	EndRun <= 1'b0;
	CalStrobe <= 1'b0;
	CALIO <= 1'b0;
	CALEN <= 1'b0;
	CALRST <= 1'b0;
	RSTchips <= 1'b0;
	ResetSlow <= 1'b0;
	Choice <= 0;
	Reset <= 1'b0;
	TagRead <= 2'b11;
	NSeqReadTag <= 0;
	Start <= 1'b0;
    TrgDlyL <= 0;
	TrgDlyR <= 0;
	$display("%g\t FPGA_DAQ_TKR12 %d: resetting.",$time,Address);
  end else if (ResetCF) begin
    PWREN <= 1'b0;     					//For safety do not enable the ASIC power at startup
    Reset <= 1'b1;
	RSTchips <= 1'b1;
	Mask <= 12'b111111111111;
	InProg <= 1'b0;
	ResetCF <= 1'b0;
	OutputUsage <= 1'b0;
	CalTrigger <= 1'b0;
  end else if (ResetHard) begin			//This reset is received from the event builder over a dedicated link
	ResetCF <= 1'b1;
	State <= Wait;
	$display("%g\t FPGA_DAQ_TKR12 %d: Hard reset received.",$time,Address);
  end else begin
    State <= NextState;
//	if (State != Wait) $display("%g\t FPGA_DAQ_TKR12 %d, CmdIn=%b, Parity=%b, State=%b",$time,Address,CmdIn,Parity,State);
	case(State)
		Wait: 	begin
					Cnt <= 0;
					Parity <= 1'b0; 
				end
		RdBt:	begin
					Cnt <= Cnt + 1;
					Parity <= Parity^CmdIn;     	//Calculate parity of the incoming address and command bits
					AddrIn <= {AddrIn[2:0],CmdIn};	//Shift in the 4-bit FPGA address of the incoming command
				end
		Brch:	begin
//					$display("%g\t FPGA_DAQ_TKR12 %d:  received command for address %b, branch to %b",$time,Address,AddrIn,CmdIn);
					Cnt <= 0;
				end
		ACmd:	begin
//					$display("%g\t FPGA_DAQ_TKR12 %d:  %b CMDtoChips=%b,  Dout=%b",$time,Address,State,CMDtoChips,Dout);
					Cnt <= Cnt + 1;
					CmdSav <= {CmdSav[8:0],CmdIn};	//Shift in the 5-bit ASIC address and 4-bit command
				end
		FeCd:	begin
//					$display("%g\t FPGA_DAQ_TKR12_TKR12:  %b CMDtoChips=%b,  Dout=%b",$time,State,CMDtoChips,Dout);
//					$display("%g\t FPGA_DAQ_TKR12 %d:  ASIC command code = %b, Chip %d, Command=%h",$time,Address,CmdSav,CmdSav[8:4],CmdSav[3:0]);
					Cnt <= 0;
					case (CmdSav[3:0])      //Set the length of the data field or returned data as appropriate for each command
						4'h0: nDat <= 0;
						4'h1: begin nDat <= 0; $display("%g\t FPGA_DAQ_TKR12 %d: soft reset going to chips.",$time,Address); end
						4'h2: begin 
								oldReadTag <= TagRead;
								nDat <= 1; 
								NReads <= NReads + 1; 
								$display("%g\t FPGA_DAQ_TKR12 %d, Send read command to chip %d",$time,Address,CmdSav[8:4]); 
							  end  
						4'h3: begin nDat <= 81;  StrtSq <= {3'b011,Address}; end
						4'h4: begin nDat <= 81;  StrtSq <= {3'b011,Address}; end
						4'h5: begin nDat <= 81;  StrtSq <= {3'b011,Address}; end
						4'h6: begin nDat <= 81;  StrtSq <= {3'b011,Address}; end
						4'h7: begin nDat <= 81;  StrtSq <= {3'b011,Address}; end
						4'h8: begin nDat <= 81;  StrtSq <= {3'b011,Address}; end
						4'h9: nDat <= 7;
						4'ha: nDat <= 7;
						4'hb: nDat <= 18;
						4'hc: nDat <= 63;
						4'hd: nDat <= 63;
						4'he: nDat <= 63;
						4'hf: begin nDat <= 7; if (ThisFPGA) CalStrobe <= 1'b1; end
					endcase 
				end
		Ct66:	begin
//					$display("%g\t FPGA_DAQ_TKR12:  %b CMDtoChips=%b,  Dout=%b",$time,State,CMDtoChips,Dout);
					Cnt <= Cnt + 1;
					TagRead <= {TagRead[0],CmdIn};  //Capture the read tag, for monitoring purposes
					if (Cnt == 1 && CmdSav[3:0] == 4'h2) begin
						if ({TagRead[0],CmdIn} != oldReadTagP1) NSeqReadTag <= NSeqReadTag + 1;
					end
					CalStrobe <= 1'b0;
					if (ReadRegCmd && Cnt>1) begin  //This timing to start shifting is dead reckoned and is fragile!
															  //This could be improved by waiting and looking for the start bit.
						case(CmdSav[8:4])			//Select the correct chip from which to receive register data
								5'b00000: StrtSq <= {StrtSq[5:0],Data[0]};         
								5'b00001: StrtSq <= {StrtSq[5:0],Data[1]};
								5'b00010: StrtSq <= {StrtSq[5:0],Data[2]};
								5'b00011: StrtSq <= {StrtSq[5:0],Data[3]};
								5'b00100: StrtSq <= {StrtSq[5:0],Data[4]};
								5'b00101: StrtSq <= {StrtSq[5:0],Data[5]};
								5'b00110: StrtSq <= {StrtSq[5:0],Data[6]};         
								5'b00111: StrtSq <= {StrtSq[5:0],Data[7]};
								5'b01000: StrtSq <= {StrtSq[5:0],Data[8]};
								5'b01001: StrtSq <= {StrtSq[5:0],Data[9]};
								5'b01010: StrtSq <= {StrtSq[5:0],Data[10]};
								5'b01011: StrtSq <= {StrtSq[5:0],Data[11]};
						endcase
					end
				end
		RdCm:	begin
					Cnt <= Cnt + 1;
					RegIn <= {RegIn[1:0],CmdIn};		//Shift in the 3-bit local command
					Parity <= Parity^CmdIn;
				end
		Deco:	begin
//					$display("%g\t FPGA_DAQ_TKR12:  local command string=%b, CmdIn=%b, Parity=%b",$time,RegIn,CmdIn,Parity);
					Parity <= Parity^CmdIn;     	//Including the parity bit in the parity calculation
					Cnt <= 0;
					CmdByte <= {CmdByte[6:0],CmdIn};    //Catch the first bit of an extended command
					if (ThisFPGA) begin
						case (RegIn)
							cmdTest: RegOut <= {2'b11,Address,Version,64'b1100010111110000011111100000111111000001111110000011111100000111}; 
//							cmdExtd: $display("%g\t FPGA_DAQ_TKR12 %d:  extended command being received.",$time,Address);
							cmdStRn: InProg <= 1'b1;
							cmdEnRn: begin
										InProg <= 1'b0;
										EndRun <= 1'b1;
									 end
							cmdRdFg: begin
										  case (Choice[3:0])
											4'h0: 	begin
														RegOut[1:0] <= 2'b11;
														RegOut[33:2] <= NFastOR;
														RegOut[65:34] <= Ntriggers;
														RegOut[77:66] <= {2'b11,Address,4'b1111,TrgErr,PrtyError};     
														PrtyError <= 1'b0;
														$display("%g\t FPGA_DAQ_TKR12 %d: NFastOR=%d, Ntriggers=%d",$time,Address,NFastOR,Ntriggers);
													end 
											4'h1:	begin
														RegOut[1:0] <= 2'b11;
														RegOut[17:2] <= NBuf1;
														RegOut[33:18] <= NBuf2;
														RegOut[49:34] <= NBuf3;
														RegOut[65:50] <= NBuf4;
														RegOut[77:66] <= {2'b11,Address,6'b111111};     
														PrtyError <= 1'b0;
														$display("%g\t FPGA_DAQ_TKR12 %d: NBuf1=%d, NBuf2=%d, NBuf3=%d, NBuf4=%d",$time,Address,NBuf1,NBuf2,NBuf3,NBuf4);
													end
											4'h2: 	begin
														RegOut[1:0] <= 2'b11;
														RegOut[17:2] <= Nsequence;
														RegOut[33:18] <= NTgPrty;
														RegOut[49:34] <= NTrgErr;
														RegOut[65:50] <= NPrtErr;
														RegOut[77:66] <= {2'b11,Address,6'b111111};
														$display("%g\t FPGA_DAQ_TKR12 %d: Nsequence=%d, NTrgErr=%d, NPrtErr=%d, NTgPrty=%d",$time,Address,Nsequence,NTrgErr,NPrtErr,NTgPrty);
													end
											4'h3:	begin
														RegOut[1:0] <= 2'b11;
														RegOut[33:2] <= NSends;
														RegOut[65:34] <= NReads;
														RegOut[77:66] <= {2'b11,Address,6'b111111};     
														PrtyError <= 1'b0;
														$display("%g\t FPGA_DAQ_TKR12 %d: NSends=%d, NReads=%d",$time,Address,NSends,NReads);
													end
											4'h4:	begin
														RegOut[1:0] <= 2'b11;
														RegOut[33:2] <= NBfClr;
														RegOut[49:34] <= NevtOut;
														RegOut[65:50] <= NSeqReadTag;
														RegOut[77:66] <= {2'b11,Address,6'b111111};
														$display("%g\t FPGA_DAQ_TKR12 %d: NSeqReadTag=%d",$time,Address,NSeqReadTag);					
													end
											4'h5:	begin
														RegOut <= {2'b11,Address,6'b111111,Mask,OutputUsage,PWREN,TrgDlyL,TrgDlyR,46'd0,2'b11};
														$display("%g\t FPGA_DAQ_TKR12 %d: Mask=%b, OutputUsage=%b, PWREN=%b",$time,Address,Mask,OutputUsage,PWREN);
													end
											4'h6:	begin
														RegOut <= {2'b11,Address,6'b111111,ErrBuf,Nerror,2'b11};
														$display("%g\t FPGA_DAQ_TKR12 %d: Error Buffer=%b, Nerror=%d",$time,Address,ErrBuf,Nerror);
													end
										  endcase
										end
							cmdRset: begin
										$display("%g\t FPGA_DAQ_TKR12 %d:  reset command received",$time,Address);
										Reset <= 1'b1;			
									 end
							cmdRsCh: begin
										$display("%g\t FPGA_DAQ_TKR12 %d:  slow reset of ASICs initiated",$time,Address);
										ResetSlow <= 1'b1;		//Reset the ASICs and then reload their configuration
									 end
							cmdSend: begin
//										$display("%g\t FPGA_DAQ_TKR12 %d:  send command received.",$time,Address);
										SendEvt <= 1'b1;		//Trigger the data merger to send out a complete event
										NSends <= NSends + 1;
									 end
						endcase
					end
				end
		WtDn:	begin
					ResetSlow <= 1'b0;			//Long millisecond wait for the reset to complete and amplifiers to settle
				end
		Prty:	begin
					if (Parity) begin
						PrtyError <= 1'b1;
						NPrtErr <= NPrtErr + 1;
						$display("%g\t FPGA_DAQ_TKR12 %d:  Parity error encountered",$time,Address);
					end
					EndRun <= 1'b0;
					SendEvt <= 1'b0;
					CALIO <= 1'b0;
					CALEN <= 1'b0;
					CALRST <= 1'b0;
					RSTchips <= 1'b0;
				end
		WrWd:	begin
					RegOut <= {RegOut[76:0],1'b0};		//Shifting out the test string or the DAQ counters
					Cnt<=Cnt+1;
				end
		CmdB:	begin									//Shift in the first byte of an extended command
					if (Cnt==6) Cnt <= 0; else Cnt <= Cnt + 1;
					Parity <= Parity^CmdIn;
					CmdByte <= {CmdByte[6:0],CmdIn};
				end
		DatB:	begin									//Shift in the data field of an extended command
					Cnt <= Cnt + 1;
					Parity <= Parity^CmdIn;
					DatByte <= {DatByte[6:0],CmdIn};
				end
		XDco:	begin
					Parity <= Parity^CmdIn;     	
//					$display("%g\t FPGA_DAQ_TKR12 %d:  extended command %b with data field %b received.",$time,Address,CmdByte,DatByte);
					if (ThisFPGA) begin
						case (CmdByte)
							8'h01:	begin
											PWREN <= DatByte[0];
											$display("%g\t FPGA_DAQ_TKR12 %d:  setting the ASIC power enable to %b",$time,Address,DatByte[0]);
									end
							8'h02:	begin
											CALIO <= 1'b1;
									end
							8'h03:	begin
											CALRST <= 1'b1;
									end
							8'h04:	begin
											CALEN <= 1'b1;
											CALINC <= DatByte[0];
									end
							8'h05:	begin
											RSTchips <= 1'b1;
											$display("%g\t FPGA_DAQ_TKR12 %d:  sending a hard reset pulse to the 12 ASICs",$time,Address);
									end
							8'h06:  begin
											Choice <= DatByte;
//											$display("%g\t FPGA_DAQ_TKR12 %d:  setting output choice to %d",$time,Address,DatByte);
									end
							8'h07:  begin
											Mask[5:0] <= DatByte[5:0];
											$display("%g\t FPGA_DAQ_TKR12 %d:  setting lower 6 bits of mask to %b",$time,Address,DatByte[5:0]);
									end
							8'h08:  begin
											Mask[11:6] <= DatByte[5:0];
											$display("%g\t FPGA_DAQ_TKR12 %d:  setting upper 6 bits of mask to %b",$time,Address,DatByte[5:0]);
									end						
							8'h09:	begin
											ResetCF <= 1'b1;
											$display("%g\t FPGA_DAQ_TKR12 %d: configuration reset.",$time,Address);
									end
							8'h0A:	begin
											OutputUsage <= DatByte[0];
											$display("%g\t FPGA_DAQ_TKR12 %d: setting output line usage to %b",$time,Address,DatByte[0]);
									end
							8'h0B:	begin
											CalTrigger <= DatByte[0];
									end
							8'h0C:	begin
										Start <= 1'b1;
									end
							8'h0D:  begin
							            TrgDlyL <= DatByte[1:0];
										TrgDlyR <= DatByte[5:4];
							        end
						endcase
					end
				end
		Tsts:	begin
					Start <= 1'b0;
					//$display("%g\t FPGA_DAQ_TKR12 %d, State Tsts: Stream=%b, Done=%b, InProg=%b, ThisFPGA=%b, Dout=%b",$time,Address,Stream,Done,InProg,ThisFPGA,Dout);
				end
	endcase
  end
end

//Generate a stream of bits to test the link to the event builder
reg Start;
genTestStream genTestStream0(Done,Stream,Start,Clock,Reset,Address);

//Matching of the address, either of this chip or the wildcard address
assign ThisFPGA = ((Address==AddrIn || AddrIn==4'hF));

//Recognize when the ASIC command will result in register data coming back
assign ReadRegCmd = (CmdSav[3:0]==4'h3) | (CmdSav[3:0]==4'h4) | (CmdSav[3:0]==4'h5) | (CmdSav[3:0]==4'h6) | (CmdSav[3:0]==4'h7) | (CmdSav[3:0]==4'h8); 

//Program to reset the ASICs without altering their registers
FeReset FeReset_U(DoneRst,CmdRst,Data,ResetSlow,Clock,Reset);

//MUX of the command line going to the chips
always @ (ThisFPGA or CmdIn or State or CmdRst) begin
	if (ThisFPGA && (State == ACmd || State == FeCd || State == Ct66)) CMDtoChips = CmdIn;  //Commands from the event builder
	else if (State == WtDn) CMDtoChips = CmdRst;											//Hand control over to the reset program
	else CMDtoChips = 1'b0;
end

// always @ (posedge Clock) begin
	// if (InProg || Data != 0) begin
		// $display("%g\t FPGA_DAQ_TKR12:  Dout=%b, Data=%b",$time,Dout,Data);
	// end
// end

//MUX of the output serial data stream
always @ (State or TOTdata or StrtSq or RegOut or ThisFPGA or InProg or ReadRegCmd or Cnt or StateTOT or MergeData or Stream)
begin
	if (State == Ct66 && ThisFPGA && ReadRegCmd) begin    			
		Dout = StrtSq[6];     												//Register data coming back from the ASICs
	end else if (ThisFPGA && State == WrWd) begin
		Dout = RegOut[77];    												//DAQ counters
	end else if (StateTOT != WaitTOT) begin
		Dout = TOTdata;														//TOT data
	end else if (InProg) begin
		Dout = MergeData;       											//Event data  
	end else if (ThisFPGA && State == Tsts) begin										
		Dout = Stream;														//Transmission test bits
	end else begin
		Dout = 1'b0;
	end
end

//Selected signals to send out to the scope probe pins on the tracker PCB
assign Diag1 = TrgPls;
assign Diag2 = Tack1;
assign Diag3 = Tack[0];
assign Diag4 = Tack[1];

//Instantiate the DAQ program that merges data from 12 chips
wire [47:0] ErrBuf;
reg [11:0] RunData;
always @ (InProg or Data) begin
	if (InProg) RunData = Data;
	else RunData = 0;
end
wire [15:0] NevtOut;
TkrDataMerge DataMerge(ErrorFE,NevtOut,MergeData,BufClr,ErrBuf,Clock,Reset,RunData,Address,SendEvt,Mask);

//always @ (posedge Tack) begin
//	$display("%g\t FPGA_DAQ_TKR12:  Tack signal",$time);
//end

//State machine to insert TOT events into the output stream when the calibration strobe is used
//Some care by the user must be taken not to send a Read command too soon after the strobe, so that this does
//not conflict with the normal event output.
//These TOT events are distinguished from real events by looking at bit 5 of the number of clusters.  That bit
//will be set for these TOT events but never for real events (since 10 is the maximum number of clusters).
//No CRC is attached to the end of these packets.

parameter [9:0] WaitTOT= 10'b0000000001; //Wait for a signal that a calibration strobe is starting
parameter [9:0] TReqTOT= 10'b0000000010; //Count until the TReq goes high
parameter [9:0] CTOTTOT= 10'b0000000100; //Count the TOT, until TReq goes low
parameter [9:0] SOutTOT= 10'b0000001000; //Initialize the output sequence, taking over the data output line
parameter [9:0] SHdrTOT= 10'b0000010000; //Shift out a 6-bit event header
parameter [9:0] SCluTOT= 10'b0000100000; //Shift out 6-bit cluster number, with exactly two "clusters" plus bit 4 set (which isn't used in data taking)
parameter [9:0] STrtTOT= 10'b0001000000; //Shift out the 12 bit start counter
parameter [9:0] STOTTOT= 10'b0010000000; //Shift out the 12 bit TOT counter.  Zero means that no TReq was encountered.  
parameter [9:0] SHitTOT= 10'b0100000000; //Shift out the 12-bit hit pattern.
parameter [9:0] SEndTOT= 10'b1000000000; //Tack a 1 bit onto the end of the stream
reg [9:0] StateTOT, NextStateTOT;
reg [11:0] CntStrt, CntTOT;
reg [11:0] TOTNclus;
reg [17:0] TOTHeader;
reg [6:0] CntShft;
parameter [11:0] MaxCnt= 12'd255;   //Maximum count allowed
reg [11:0] TReqLatch;				//Bit pattern of ASIC TReq signals received

//always @ (posedge Clock) begin
//	$display("%g\t   %b    %b     %b     %d    %d   %d   %b %b %b ",$time,StateTOT,TReqChip,CalStrobe,CntStrt,CntTOT,CntShft,TOTHeader,TOTNclus,TOTdata);
//end

always @ (StateTOT or CntStrt or CntTOT or CntShft or TOTHeader or TOTNclus or CalStrobe or TReqChip or TReqLatch)
begin
	case (StateTOT)
		WaitTOT: 	begin
						TOTdata = 1'b0;
						if (CalStrobe) NextStateTOT = TReqTOT;
						else NextStateTOT = WaitTOT;
					end
		TReqTOT:	begin
						TOTdata = 1'b0;
						if (CntStrt == MaxCnt) NextStateTOT = SOutTOT;  //No TReq found; Send out empty event
						else if (TReqChip) NextStateTOT = CTOTTOT;
						else NextStateTOT = TReqTOT;
					end
		CTOTTOT:	begin
						TOTdata = 1'b0;
						if (!TReqChip || CntTOT == MaxCnt) NextStateTOT = SOutTOT;
						else NextStateTOT = CTOTTOT;
					end
		SOutTOT:	begin
						TOTdata = 1'b0;
						NextStateTOT = SHdrTOT;
					end
		SHdrTOT:	begin
						if (CntShft == 17) begin
							NextStateTOT = SCluTOT;
						end else begin
							NextStateTOT = SHdrTOT;
						end
						TOTdata = TOTHeader[17];
					end
		SCluTOT:	begin
						if (CntShft == 29) begin
							NextStateTOT = STrtTOT;
						end else begin
							NextStateTOT = SCluTOT;
						end
						TOTdata = TOTNclus[11];
					end
		STrtTOT:	begin
						if (CntShft == 41) begin
							NextStateTOT = STOTTOT;
						end else begin
							NextStateTOT = STrtTOT;
						end
						TOTdata = CntStrt[11];
					end
		STOTTOT:	begin
						if (CntShft == 53) begin
							NextStateTOT = SHitTOT;
						end else begin
							NextStateTOT = STOTTOT;
						end
						TOTdata = CntTOT[11];
					end
		SHitTOT:	begin
						if (CntShft == 65) NextStateTOT = SEndTOT;
						else NextStateTOT = SHitTOT;
						TOTdata = TReqLatch[11];
					end
		SEndTOT: begin
						NextStateTOT = WaitTOT;
						TOTdata = 1'b1;
					end
		default:	begin
						TOTdata = 1'b0;
						NextStateTOT = WaitTOT;
					end
	endcase
end

always @ (posedge Clock)
begin
	if (Reset) begin
		StateTOT <= WaitTOT;
	end else begin
		StateTOT <= NextStateTOT;
		if (StateTOT == TReqTOT || StateTOT == CTOTTOT) begin
			if (TReq[0]) TReqLatch[0] <= 1'b1;
			if (TReq[1]) TReqLatch[1] <= 1'b1;
			if (TReq[2]) TReqLatch[2] <= 1'b1;
			if (TReq[3]) TReqLatch[3] <= 1'b1;
			if (TReq[4]) TReqLatch[4] <= 1'b1;
			if (TReq[5]) TReqLatch[5] <= 1'b1;
			if (TReq[6]) TReqLatch[6] <= 1'b1;
			if (TReq[7]) TReqLatch[7] <= 1'b1;
			if (TReq[8]) TReqLatch[8] <= 1'b1;
			if (TReq[9]) TReqLatch[9] <= 1'b1;
			if (TReq[10]) TReqLatch[10] <= 1'b1;
			if (TReq[11]) TReqLatch[11] <= 1'b1;									
		end
//		if (StateTOT != WaitTOT) $display("%g\t StateTOT=%b, CntStrt=%b, CntTOT=%b, TOTdata=%b, CntShft=%d, TOTHeader=%b, TOTNclus=%b, TReqLatch=%b, TReq=%b",$time,StateTOT,CntStrt,CntTOT,TOTdata,CntShft,TOTHeader,TOTNclus,TReqLatch,TReq); 
		case (StateTOT)
			WaitTOT: 	begin
							CntStrt <= 0;
							CntTOT <= 0;
							TReqLatch <= 0;
						end
			TReqTOT:	begin
							CntStrt <= CntStrt + 1;				
						end
			CTOTTOT:	begin
							CntTOT <= CntTOT + 1;
						end
			SOutTOT:	begin
							TOTNclus  <= 12'b010011001111;
							TOTHeader <= {2'b10,Address,12'b111111100001};
							CntShft <= 0;
						end
			SHdrTOT:	begin
							TOTHeader <= {TOTHeader[16:0],1'b0};
							CntShft <= CntShft + 1;
						end
			SCluTOT:	begin
							TOTNclus <= {TOTNclus[10:0],1'b0};
							CntShft <= CntShft + 1;
						end
			STrtTOT:	begin
							CntStrt <= {CntStrt[10:0],1'b0};
							CntShft <= CntShft + 1;
						end
			STOTTOT:	begin
							CntTOT <= {CntTOT[10:0],1'b0};
							CntShft <= CntShft + 1;
						end
			SHitTOT:	begin
							CntShft <= CntShft + 1;
							TReqLatch <= {TReqLatch[10:0],1'b0};
						end
		endcase
	end
end

endmodule
	